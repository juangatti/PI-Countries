import _JSXStyle from "styled-jsx/style";
import React, { useRef, useImperativeHandle, useLayoutEffect } from 'react';
import useTheme from '../use-theme';
import withDefaults from '../utils/with-defaults';
import Input from '../input';
import useResize from '../use-resize';
import useWarning from '../use-warning';
import { excludedInputPropsForTextarea } from '../utils/prop-types';
import { __DEV__ } from '../utils/assertion';
import { calculateNodeHeight, getSizingData } from './utils';
import { jsx as _jsx } from "react/jsx-runtime";
import { Fragment as _Fragment } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
const defaultProps = {
  minRows: 3,
  maxRows: 6,
  cacheMeasurements: true,
  initialValue: '',
  width: 'initial'
};
const Textarea = /*#__PURE__*/React.forwardRef((textareaProps, ref) => {
  const theme = useTheme();
  const textareaRef = useRef(null);
  const heightRef = React.useRef(0);
  const measurementsCacheRef = React.useRef();
  const {
    width,
    cacheMeasurements,
    rows,
    maxRows,
    minRows,
    onChange,
    onHeightChange,
    ...props
  } = textareaProps;
  Object.keys(props).forEach(propNameKey => {
    if (excludedInputPropsForTextarea.indexOf(propNameKey) > -1) {
      // @ts-ignored
      delete props[propNameKey];
    }
  });
  const isControlled = props.value !== undefined;

  if (__DEV__ && props.style) {
    if ('maxHeight' in props.style) {
      useWarning('Using `style.maxHeight` for <Textarea/> is not supported. Please use `maxRows`.');
    }

    if ('minHeight' in props.style) {
      useWarning('Using `style.minHeight` for <Textarea/> is not supported. Please use `minRows`.');
    }
  }

  useImperativeHandle(ref, () => textareaRef.current);

  const resizeTextarea = () => {
    const node = textareaRef.current;
    const nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData(node);

    if (!nodeSizingData) {
      return;
    }

    measurementsCacheRef.current = nodeSizingData;
    const [height, rowHeight] = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || 'x', rows || minRows, rows || maxRows);

    if (heightRef.current !== height) {
      heightRef.current = height;
      node.style.setProperty('height', `${height}px`, 'important');
      onHeightChange && onHeightChange(height, {
        rowHeight
      });
    }
  };

  const handleChange = event => {
    if (!isControlled) {
      resizeTextarea();
    }

    onChange && onChange(event);
  };

  if (typeof document !== 'undefined') {
    useLayoutEffect(resizeTextarea);
    useResize(resizeTextarea);
  }

  return /*#__PURE__*/_jsxs(_Fragment, {
    children: [/*#__PURE__*/_jsx(Input, {
      as: "textarea",
      ref: textareaRef,
      width: width,
      onChange: handleChange,
      ...props
    }), /*#__PURE__*/_jsx(_JSXStyle, {
      id: "1093480011",
      dynamic: [width, theme.font.sans, theme.layout.gapHalf],
      children: `.textarea-wrapper{box-sizing:border-box;width:${width};min-width:12.5rem;max-width:100%;height:auto;}textarea{background-color:transparent;box-shadow:none;display:block;font-family:${theme.font.sans};padding:${theme.layout.gapHalf};width:100%;height:100%;resize:none;border:none;outline:none;}`
    })]
  });
});

if (__DEV__) {
  Textarea.displayName = 'NextUI - Textarea';
}

export default withDefaults(Textarea, defaultProps);