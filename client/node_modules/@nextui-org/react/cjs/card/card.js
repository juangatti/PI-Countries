"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _style = _interopRequireDefault(require("styled-jsx/style"));

var _react = _interopRequireWildcard(require("react"));

var _useTheme = _interopRequireDefault(require("../use-theme"));

var _styles = require("./styles");

var _cardHeader = _interopRequireDefault(require("./card-header"));

var _cardFooter = _interopRequireDefault(require("./card-footer"));

var _cardBody = _interopRequireDefault(require("./card-body"));

var _image = _interopRequireDefault(require("../image"));

var _clsx = _interopRequireDefault(require("../utils/clsx"));

var _drip = _interopRequireDefault(require("../utils/drip"));

var _useDrip = _interopRequireDefault(require("../use-drip"));

var _collections = require("../utils/collections");

var _dimensions = require("../utils/dimensions");

var _cardContext = require("./card-context");

var _styles2 = require("../utils/styles");

var _useKeyboard = _interopRequireWildcard(require("../use-keyboard"));

var _assertion = require("../utils/assertion");

var _jsxRuntime = require("react/jsx-runtime");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const defaultProps = {
  color: 'default',
  textColor: 'default',
  bordered: false,
  cover: false,
  animated: true,
  clickable: false,
  hoverable: false,
  shadow: true,
  borderWeight: 'normal',
  width: '100%',
  height: 'auto',
  className: ''
};

const Card = /*#__PURE__*/_react.default.forwardRef(({ ...cardProps
}, ref) => {
  const {
    children,
    bordered,
    cover,
    className,
    shadow,
    animated,
    clickable,
    hoverable,
    color: cardColor,
    borderWeight: borderWeightProp,
    width,
    height,
    textColor,
    onClick,
    ...props
  } = cardProps;
  const theme = (0, _useTheme.default)();
  const {
    color,
    bgColor,
    dripColor,
    borderColor
  } = (0, _react.useMemo)(() => (0, _styles.getStyles)(cardColor, textColor, shadow, bordered, theme), [cardColor, theme, textColor, shadow, bordered]);
  const cardRef = (0, _react.useRef)(null);
  (0, _react.useImperativeHandle)(ref, () => cardRef.current);
  const {
    onClick: onDripClickHandler,
    ...dripBindings
  } = (0, _useDrip.default)(false, cardRef);
  const [withoutHeaderChildren, headerChildren] = (0, _collections.pickChild)(children, _cardHeader.default);
  const [withoutFooterChildren, footerChildren] = (0, _collections.pickChild)(withoutHeaderChildren, _cardFooter.default);
  const [withoutImageChildren, imageChildren] = (0, _collections.pickChild)(withoutFooterChildren, _image.default);
  const {
    className: focusClassName,
    styles: focusStyles
  } = (0, _styles2.getFocusStyles)(theme);
  const hasContent = (0, _collections.hasChild)(withoutImageChildren, _cardBody.default);
  const hasHeader = (0, _collections.hasChild)(children, _cardHeader.default);
  const borderWeight = (0, _react.useMemo)(() => bordered ? (0, _dimensions.getNormalWeight)(borderWeightProp) : '0px', [bordered, borderWeightProp]);
  const cardConfig = (0, _react.useMemo)(() => ({
    background: bgColor,
    noPadding: cover ? true : undefined
  }), []);

  const clickHandler = event => {
    if (animated && cardRef.current) {
      onDripClickHandler(event);
    }

    onClick && onClick(event);
  };

  const {
    bindings
  } = (0, _useKeyboard.default)(event => {
    if (!clickable) {
      return;
    }

    clickHandler(event);
  }, [_useKeyboard.KeyCode.Enter, _useKeyboard.KeyCode.Space], {
    disableGlobalEvent: true
  });
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_cardContext.CardContext.Provider, {
    value: cardConfig,
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      ref: cardRef,
      tabIndex: clickable ? 0 : -1,
      onClick: clickHandler,
      ...props,
      ...bindings,
      className: _style.default.dynamic([["1879174986", [bgColor, width, height, theme.layout.radius, shadow && !bordered ? theme.expressiveness.shadowMedium : 'none', color, borderWeight, borderColor, shadow ? theme.expressiveness.shadowLarge : '']]]) + " " + (bindings && bindings.className != null && bindings.className || props && props.className != null && props.className || (0, _clsx.default)('card', {
        animated,
        cover,
        clickable,
        hoverable
      }, clickable && focusClassName, className) || ""),
      children: [hasHeader ? /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
        children: [headerChildren, imageChildren]
      }) : imageChildren, hasContent ? withoutImageChildren : !cover ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_cardBody.default, {
        children: withoutImageChildren
      }) : null, clickable && animated && /*#__PURE__*/(0, _jsxRuntime.jsx)(_drip.default, {
        color: dripColor,
        ...dripBindings
      }), footerChildren, /*#__PURE__*/(0, _jsxRuntime.jsx)(_style.default, {
        id: "1879174986",
        dynamic: [bgColor, width, height, theme.layout.radius, shadow && !bordered ? theme.expressiveness.shadowMedium : 'none', color, borderWeight, borderColor, shadow ? theme.expressiveness.shadowLarge : ''],
        children: `.card.__jsx-style-dynamic-selector{margin:0;padding:0;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;overflow:hidden;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background:${bgColor};width:100%;max-width:${width};height:${height};border-radius:${theme.layout.radius};box-shadow:${shadow && !bordered ? theme.expressiveness.shadowMedium : 'none'};box-sizing:border-box;color:${color};border:${borderWeight} solid ${borderColor};}.card.animated.__jsx-style-dynamic-selector{-webkit-transition:all 0.25s ease;transition:all 0.25s ease;}.card.clickable.animated.__jsx-style-dynamic-selector:active{-webkit-transform:scale(0.97);-ms-transform:scale(0.97);transform:scale(0.97);}.card.hoverable.clickable.animated.__jsx-style-dynamic-selector:active{-webkit-transform:scale(0.99);-ms-transform:scale(0.99);transform:scale(0.99);}.card.clickable.__jsx-style-dynamic-selector{cursor:pointer;}.card.__jsx-style-dynamic-selector .image{width:100%;}.card.hoverable.animated.__jsx-style-dynamic-selector:hover{-webkit-transform:translateY(-2px);-ms-transform:translateY(-2px);transform:translateY(-2px);box-shadow:${shadow ? theme.expressiveness.shadowLarge : ''};}.card.cover.__jsx-style-dynamic-selector img{object-fit:cover;}.card.__jsx-style-dynamic-selector:not(.cover) .image{border-bottom-left-radius:0;border-bottom-right-radius:0;}`
      }), focusStyles]
    })
  });
});

if (_assertion.__DEV__) {
  Card.displayName = 'NextUI - Card';
}

Card.defaultProps = defaultProps;
var _default = Card;
exports.default = _default;
module.exports = exports.default;